// --- Helper: Generic D3 Chart Setup Items ---
    function setupChartAxesAndLabelsGlobal(svg, scales, margins, width, height, axisConfig) {
        svg.append("g")
            .attr("transform", `translate(0,${height})`) 
            .call(d3.axisBottom(scales.x).ticks(axisConfig.x.ticksType.every(axisConfig.x.ticksInterval)).tickFormat(d3.timeFormat(axisConfig.x.tickFormat)))
            .selectAll("text") 
            .style("text-anchor", "end").attr("dx", "-.8em").attr("dy", ".15em").attr("transform", "rotate(-45)");
        svg.append("text").attr("class", "axis-label") 
            .attr("text-anchor", "middle")
            .attr("x", width / 2)
            .attr("y", height + margins.bottom / 1.5 + 15) 
            .text(axisConfig.x.label);
        svg.append("g").call(d3.axisLeft(scales.yLeft));
        svg.append("text").attr("class", "axis-label") 
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margins.left + 15)
            .attr("x", 0 - (height / 2))
            .text(axisConfig.yLeft.label);
        if (scales.yRight && axisConfig.yRight) {
            svg.append("g").attr("transform", `translate(${width},0)`).call(d3.axisRight(scales.yRight));
            svg.append("text").attr("class", "axis-label") 
                .attr("transform", "rotate(-90)")
                .attr("y", width + margins.right - 20) 
                .attr("x", 0 - (height / 2))
                .text(axisConfig.yRight.label);
        }
    }
    function setupTooltipInteractionGlobal(svg, tooltip, data, scales, lineFocusCircles, bisector, dateFormatter, width, height, getTooltipHtmlCallback) {
        const focus = svg.append("g").attr("class", "focus").style("display", "none"); 
        
        let focusLineStroke = "#1E3A8A"; // Default for light backgrounds
        const chartWrapper = svg.node().closest(".chart-wrapper"); // Get the parent chart wrapper
        if (chartWrapper) {
            const bgColor = window.getComputedStyle(chartWrapper).backgroundColor;
            // Check for the specific dark blue of the James chart IF its background was dark
            // Since all chart backgrounds are now light blue (#D6EAF8), this check can be simplified
            // or we can rely on CSS to set focus line color based on a class on the chart-wrapper if needed.
            // For now, assuming light background means dark focus line.
            // If James chart was still dark:
            // if (bgColor === 'rgb(30, 58, 138)' || bgColor === '#1e3a8a') { 
            //      focusLineStroke = "white";
            // }
        }
        
        focus.append("line").attr("class", "focus-line-y").attr("y1", 0).attr("y2", height)
             .style("stroke", focusLineStroke).style("stroke-width", 0.5).style("stroke-dasharray", "3,3"); 
        const circles = {}; 
        for (const key in lineFocusCircles) {
            circles[key] = focus.append("circle").attr("r", 4).style("fill", "none").style("stroke", lineFocusCircles[key].color);
        }
        svg.append("rect").attr("class", "overlay").attr("width", width).attr("height", height)
            .style("fill", "none").style("pointer-events", "all")
            .on("mouseover", () => { focus.style("display", null); tooltip.style("opacity", 1); })
            .on("mouseout", () => { focus.style("display", "none"); tooltip.style("opacity", 0); })
            .on("mousemove", function(event) { 
                const x0 = scales.x.invert(d3.pointer(event, this)[0]); 
                const i = bisector(data, x0, 1); 
                const d0 = data[i - 1];
                const d1 = data[i];
                const d = (d1 && (x0 - d0.date > d1.date - x0)) ? d1 : d0; 
                if (!d) return; 
                focus.attr("transform", `translate(${scales.x(d.date)},0)`); 
                for (const key in circles) {
                    if (d[lineFocusCircles[key].dataKey] !== undefined && !isNaN(d[lineFocusCircles[key].dataKey])) {
                       circles[key].attr("cy", lineFocusCircles[key].yScale(d[lineFocusCircles[key].dataKey]));
                    } else { circles[key].attr("cy", -1000); }
                }
                tooltip.html(getTooltipHtmlCallback(d, dateFormatter)) 
                       .style("left", (event.pageX + 15) + "px") 
                       .style("top", (event.pageY - 28) + "px");
            });
    }
    function createLegendGlobal(legendContainerSelector, legendData) {
        const legend = d3.select(legendContainerSelector).html(""); 
        legendData.forEach(item => {
            const legendItem = legend.append("div").attr("class", "legend-item");
            const colorBox = legendItem.append("span").attr("class", "legend-color-box");
            if (item.dasharray && item.dasharray !== "none") { 
                colorBox.style("background-color", "transparent")
                        .style("border", `2px ${item.dasharray === "3,3" ? 'dotted' : 'dashed'} ${item.color}`);
            } else { 
                colorBox.style("background-color", item.color)
                        .style("border", `2px solid ${item.color}`);
            }
            legendItem.append("span").text(item.label);
        });
    }
